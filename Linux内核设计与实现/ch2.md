
# 从内核出发

## 编译内核
配置内核
- make configure，此工具会逐一遍历所有配置项，要求用户选择，耗费大量时间
- 推荐基于ncurse库的图形界面工具make menuconfig或者基于gtk+的图形工具make gconfig

这些配置项存放在内核代码树根目录下的.config文件中

编译
- make
- make -jn(n为整数，例如make -j8) 多线程编译，加快速度


## 内核开发特点

### 无标准头文件。  
内核不能链接使用标准c函数库，原因有很多，其中最重要的原因还是速度和大小问题，对于内核而言，完整或者部分C库都太大且太低效了。很多常用的C库函数在内核内都已经得到实现。在没有实现的函数中，最著名的数printf函数了，内核提供了printk函数，负责将格式化的字符串拷贝到内核日志缓冲区，使得syslog可以通过该缓冲区获取内核信息。printk函数提供了优先级标志。

### GNU C
1.内联(inline)函数。   
inline函数会在被调用的位置上展开，这么做可以消除函数调用和返回带来的开销（寄存器存储和恢复），而且由于编译器将调用函数的代码和函数本身放在一起，带来了进一步优化的可能。缺点在于，代码会变长，会占用更多的内存空间或者指令缓存。内核开发者通常把那些对时间要求较高，而本身长度较短的函数定义成内联函数。使用static关键字和inline修饰。
```c
static inline  void  wolf(unsigned long tail_size) ;
``` 

2.内联汇编  
gcc支持在C函数中嵌入汇编。  

3.分支声明  
gcc内建了一条指令用于优化条件选择语句，内核把这条指令封装成了宏，比如likely和unlikely。当一个条件很少出现时，可以用unlikely来进行标记。相反的可以用likely进行标记。编译器可以根据这条指令对条件分支进行优化。
```c
//例子
if(unlikely(error)){

}
```
### 没有内存保护机制  
如果用户程序试图非法访问内存，内核会发现这个错误，发送SIGSEGV信号，并结束此进程。而如果内核自己非法访问内存时，后果就难以控制。  
内核中的内存不分页，所以你每用掉一个字节，物理内存就少一个字节。  

### 不要轻易在内核中使用浮点数  
在用户进程中进行浮点操作时，内核会完成从整数到浮点数操作的模式转换。在执行浮点指令时到底会做什么，因体系结构不同，内核的选择也会不同。  
与用户空间进程不同，内核不能完美的支持浮点操作，因为他本身不能陷入，在内核这使用浮点数时，除了人工保存和恢复浮点寄存器外，还有其他的一些琐碎的事情要做。   

### 容积小而固定的栈  
内核栈通常容积较小而且固定。  

### 同步和并发
内核很容易产生竞争条件，并且其许多特性都要求能够并发的访问共享数据。  
常用的解决竞争的办法是自旋锁和信号量。  

### 可移植性的重要性  
大部分C代码应该与体系结构无关，也即在不同的体系结构上都能编译和执行，因此需要把与体系结构相关的代码适当地分离出来。


