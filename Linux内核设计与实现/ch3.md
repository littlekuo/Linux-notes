# 进程管理

## 进程
1.进程是处于执行期的程序以及相关资源的总称，通常包括  
- 打开的文件
- 挂起的信号
- 内核数据结构
- 处理器状态
- 具有内存映射的内存地址空间
- 存放全局变量的数据段 
- 等等  
 
2.线程是在进程中的活动对象。  
每个线程独有：
- 独立的程序计数器
- (进程)栈
- 一组(进程)寄存器  
  
括号里写进程二字的原因在于Linux并不对线程和进程特别区分，线程只是一种特殊的进程。

进程创建通常是调用fork()的结果，fork()系统调用从内核中return两次，一次是父进程，另一次是新产生的子进程。  

通常，创建新进程都是为了执行新的程序，接着调用exec()函数就可以创建新的地址空间，把新程序载入其中。最终，程序通过exit()系统调用退出执行，这个函数会终结进程并释放其占用资源。父进程可以通过wait()系统调用查询子进程是否终结。进程退出执行后被设置为僵死状态，直到其父进程调用wait或者waitpid()为止。


## 进程描述符以及结构
内核将进程的列表存放在名为task list的双向循环链表中。
链表中的每一项都是类型为task_struct，称作进程描述符(process descriptor)的结构。进程描述符包含一个具体进程的所有信息。  
```c
//代码来自linux 2.6.26
struct task_struct {
	volatile long state;	/* -1 unrunnable, 0 runnable, >0 stopped */
	void *stack;
	atomic_t usage;
	unsigned int flags;	/* per process flags, defined below */
	unsigned int ptrace;

	int lock_depth;		/* BKL lock depth */
    
    ...
    ...
};

```

### 分配进程描述符

Linux通过slab分配器分配task_struct结构，从而达到对象复用和缓存着色的效果。  
在2.6以前的内核，各个进程的task_struct放在内核栈的尾端，这样做是为了让那些像x86那样寄存器较少的硬件体系结构只要通过栈指针就能算出它的位置。现在用slab分配器动态生成task_struct，所以只需要在栈底（向下增长的栈）或栈顶（向上增长的栈）创建一个新结构struct thread_info。

### 进程描述符的存放
内核通过一个唯一的进程标识值(PID)来识别每个进程。PID表示为pid_t隐含类型，实际就是int类型。  
PID的默认值是32678，内核将每个进程的PID放在它们各自的进程描述符中。  
在内核中，访问任务通常需要获得指向其task_struct的指针。因此，通过current宏找到当前正在运行的进程的进程描述符的速度至关重要。  
硬件体系不同，该宏的实现也不同，有的硬件体系可以专门拿出一个寄存器来存放指向当前task_struct的指针，而像x86这种寄存器并不富余的结构，就只能在内核栈的尾端创建thread_info结构，通过计算偏移间接地查找task_struct结构。

### 进程状态
task_struct中的state域描述了当前进程的状态。该域的值有五种：
- TASK_RUNNING(运行) —— 进程是可执行的；或者进程正在执行，或者在运行队列中等待执行，这是进程在用户空间中的唯一可能状态。
- TASK_INTERRUPTIBLE(可中断) —— 进程正在睡眠，等待某些条件达成，达成后内核会把进程状态设置成运行。
- TASK_UNINTERRUPTIBLE(不可中断) —— 与可中断状态不同，处于此状态就算是接收到信号也不会被唤醒或者投入运行。这个状态通常在进程必须在等待时不受干扰或者等待事件很快就会发生时出现。使用较少。
- _TASK_TRACED —— 被其他进程跟踪的进程
- _TASK_STOPPED —— 进程停止运行；进程没有投入运行也无法投入运行。

### 设置当前进程状态
设置进程状态最好使用 set_task_state(task, state)函数
```c
set_task_state(task, state);
```
该函数会将指定的进程设置为指定状态，必要时候，它会设置内存屏障来强制其他处理器做重新排序。否则其等价于
```
task -> state = state;
```

### 进程上下文
一般程序在用户空间执行，当其执行系统调用时或者触发某个异常时，它就陷入了内核空间。  
此时，我们称内核“代表进程执行”并处于进程上下文中。在此上下文中current宏是有效的（注意与中断上下文区别）。除非在此间隙有优先级更高的进程需要执行且调度器做出了处理，否则在内核退出时，程序恢复在用户空间继续执行。

### 进程家族树
在linux系统中，所有进程都是 PID为1的init进程的后代。内核在启动的最后阶段启动init进程。该进程读取系统的初始化脚本并执行其他相关程序，最终完成整个启动过程。  
系统中每个进程都有一个父进程，有零个或多个子进程。拥有同一个父进程的所有进程称作 兄弟。每个task_struct都有一个指向父进程名为parent的指针，还有一个称作children的子进程链表。  
通过这种继承关系从系统的任何一个进程出发都能找到任意指定的其他进程。但大多数时候，因为任务队列本就是一个双向循环链表，所以遍历就可以找到系统中的任何进程。

## 进程创建
与其他操作系统提供产生（spawn）进程的机制不同，Unix采用了与众不同的实现方式，它把上述步骤分解到两个单独的函数中进行：fork() 和 exec() (这里的exec是指一族函数)。  
首先，fork()通过拷贝当前进程创建一个子进程，子进程与父进程的区别仅仅在于 PID, PPID和某些资源与统计量（比如挂起的信号，子进程没必要继承）。exec()函数负责读取可执行文件并将其载入地址空间运行。

### 写时拷贝
传统的fork系统调用直接将所有的资源复制到新创建的进程，这种实现过于简单且效率不高，因为它拷贝的数据也许不共享。并且如果新进程打算执行一个新的映像，则所有拷贝前功尽弃。  
Linux的fork()使用copy-on-write页实现。copy-on-write是一种推迟甚至免除拷贝的技术，内核此时并不复制整个进程地址空间，而是让子进程和父进程共享同一个拷贝。  
只有当需要写入时，数据才会被复制，从而使各个进程拥有各自的拷贝。也就是说，资源的复制只有在需要写入时才发生，在此之前是以只读方式共享。  
fork()的实际开销就是复制父进程的页表以及给子进程创建唯一的进程描述符。上述优化可以避免拷贝大量根本就不会用到的数据。

### fork()
Linux通过clone()实现fork()。fork(), vfork()和__clone()都根据各自需要的参数去调用clone()，然后由clone去调用do_fork()。  
do_fork()完成创建中的大部分工作，其定义在kernel/fork.c文件中。其调用copy_process()函数，然后让进程开始运行。  
copy_process函数完成的工作如下：
- 调用dup_task_struct为新进程创建一个内核栈，thread_info和task_struct，这些值和当前进程相同，此时子进程和当前进程的描述符是完全相同的。
- 检查并确保新创建子进程后，当前用户所拥有的进程数量没有超过给它分配的资源的限制。
- 子进程着手使自己与父进程区别开。task_struct中的许多成员要被清零。
- 子进程的状态被设置成TASK_UNINTERRUPTIBLE，以保证它不会被投入运行。
- copy_process函数调用copy_flags()以更新task_struct的flags成员。表明进程是否有超级权限的PF_SUPERPRIV标志被清零，表明进程还没有调用exec()函数的PF_FORKNOEXEC标志被设置。
- 调用alloc_pid()为新进程分配一个有效的PID
- 根据传递给clone()的参数标志，copy_process()拷贝或共享打开的文件、文件系统信息、信号处理函数、进程地址空间和命名空间等。一般情况下，这些资源会被给定进程的所有线程共享；否则，这些资源对每个进程是不同的，因此被拷贝到这里。
- copy_process()函数做收尾工作并返回一个指向子进程的指针。

### vfork()
除了不拷贝父进程的页表项外，vfork()系统调用和fork()功能相同。现在由于在执行fork()是引入了写时拷贝页并且明确子进程先执行，vfork()的好处就仅限于不拷贝父进程的页表项，如果将来fork()有了写时拷贝页表项，那么vfork()的优势就没了。由于vfork()语意比较微妙，理想情况下最好不要使用。


## 线程在Linux中的实现
线程机制是现代操作系统的一种抽象概念，它提供了在同一程序内 共享内存地址空间 运行的一组活动。  
Linux实现线程的机制比较独特，从内核角度来看，它实际上没有线程这个概念，线程仅仅被视作一个与其他进程共享某些资源的进程，每个线程都有唯一的一个task_struct，所以在内核中，它与普通进程区别不大。  
上述线程机制的实现与windows和Solaris等操作系统的实现差异很大，这些系统在内核中提供了专门支持线程的机制。在这些系统中，线程被称作lightweight process，而对于Linux而言，它只是进程间共享资源的一种手段（linux进程本身就够轻量了）。举个例子，在专门提供






## 未完



