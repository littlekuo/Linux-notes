
# 多处理器调度

到目前为止，我们讨论了许多单处理器调度的原则，那么如何扩展到多处理器上呢？


## 背景：多处理器架构
多处理器和单处理器的核心区别：对硬件缓存的使用和处理器之间共享数据的方式。

缓存一致性问题：硬件提供了基本的解决方案，通过监控内存访问，硬件可以保证获得正确的数据，从而保证共享内存的唯一性。例如总线窥探(bus snooping):
> 每个缓存都通过监听链接所有缓存和内存的总线，来发现内存访问，如果CPU发现对它放在缓存的数据进行更新，则会作废本地副本（从缓存中移除），或者更新它，回写缓存。


## 别忘了同步
最简单的方法是加锁，但会带来性能问题。

## 最后一个问题：缓存亲和度
缓存亲和度(cache affinity):
> 一个进程在某个CPU上运行时，会在该CPU中的缓存维护许多状态，下次在相同CPU上运行时，由于缓存中的数据会执行得更快。相反，在不同CPU上运行时，由于需要重新加载数据而很慢。  

因此多处理器应该考虑到这种缓存亲和性，尽量将进程保持在同一个CPU上。

## 单队列调度
最简单的方式就是将所有需要调度的工作放在一个单独的队列中，称作单队列多处理器调度(SQMS)。   
优点：
> 简单  

缺点：
> 1.缺乏扩展性，访问单个队列需要加锁，但是随着CPU增加将带来巨大的开销。  
> 2.不利于缓存亲和性。

## 多队列调度
多队列多处理器调度(MQMS)。  
优点：
> 扩展性好，缓存亲和度好 

缺点：
> 可能会带来负载不均衡问题

如何应对负载不均问题?  
最明显的答案是让工作跨CPU移动，称之为迁移。最棘手的部分是系统如何决定发起这样的迁移？
> 一个最基本的技术：工作窃取(work stealing)。工作量少的队列不定期地"偷看"其他队列是不是比自己工作多，如果显著的多，就从目标队列"窃取"一个或多个工作，实现负载均衡。

## Linux多处理器调度
Linux社区一直以来，存在三种不同的调度程序：
> O(1)调度，完全公平调度(CFS)和BF调度程序(BFS)。 
 
这里我们只将一些基本知识。  
> O(1), CFS采用多级队列，BFS采用单级队列，这说明两种方法都可以成功。它们之间也有很多不同的细节，比如，O(1)是基于优先级的，随时间推移改变进程优先级，然后调度最高优先级进程。与之不同，CFS是确定的比例调度算法。BFS作为三个算法中唯一采用单队列的算法，也基于比例调度，但采用了更复杂的方案，称作最早最合适虚拟截止时间优先算法(EEVEF)。




